\begin{code}[hide]%
\>[0]\AgdaComment{--\ Cannot\ be\ safe\ because\ we\ postulate\ funext}\<%
\\
\>[0]\AgdaComment{--\ \{-\#\ OPTIONS\ --safe\ \#-\}}\<%
\\
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{2-overview}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Agda.Primitive}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{Setω}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaPrimitive{Typeω}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function.Properties.Equivalence}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{⇔}\<%
\\
%
\>[4]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Bool}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Bool}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Bool}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Bool}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Char}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{Char}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{List}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{foldl}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Sum}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Decidable}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Dec}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{from-yes}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{from-no}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Reflects}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ofʸ}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ofⁿ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Level}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPrimitive{zero}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{suc}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Negation}\<%
\\
%
\>[4]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.String}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{String}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Agda.Builtin.FromString}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{transport}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[4]\AgdaFunction{transport}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{≡→⇔}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[4]\AgdaFunction{≡→⇔}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{lift⊎₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaBound{D}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{C}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{D}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{D}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{D}\<%
\\
%
\>[4]\AgdaFunction{lift⊎₂}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{lift⊎₂}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
%
\>[4]\AgdaFunction{lift⊎₂}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{String}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\<%
\\
%
\>[4]\AgdaFunction{String}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaPostulate{Char}\<%
\\
%
\>[4]\AgdaKeyword{instance}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaFunction{string}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{IsString}\AgdaSpace{}%
\AgdaFunction{String}\<%
\\
%
\>[8]\AgdaField{IsString.Constraint}\AgdaSpace{}%
\AgdaFunction{string}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
%
\>[8]\AgdaField{IsString.fromString}\AgdaSpace{}%
\AgdaFunction{string}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{String.toList}\AgdaSpace{}%
\AgdaBound{xs}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{foldl}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ℓ₁}\AgdaSpace{}%
\AgdaBound{ℓ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ℓ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ℓ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{List}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
%
\>[4]\AgdaFunction{foldl}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{z}\<%
\\
%
\>[4]\AgdaFunction{foldl}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{foldl}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaGeneralizable{ℓ}\AgdaSpace{}%
\AgdaGeneralizable{ℓ′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\<%
\\
%
\>[8]\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaGeneralizable{ℓ}\<%
\\
%
\>[8]\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaGeneralizable{c'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Char}\<%
\\
%
\>[8]\AgdaGeneralizable{w}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\<%
\end{code}

\section{Finite Languages}\label{sec:finite-languages}

In this section, we introduce background information, namely how we define languages, basic language combinators, and parsers. Our exposition follows Elliott~\cite{conal-languages}. In \cref{sec:context-free}, we extend these concepts to context free languages.

\subsection{Languages}

We define languages as being functions from strings to types.\footnote{We use \af{Type} as a synonym for Agda's \af{Set} to avoid confusion with set-theoretic sets.}%
\begin{code}[hide]%
\>[0]\AgdaComment{--\ module\ ◇\ where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type₁}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Type}\<%
\end{code}
The result type can be thought of as the proposition that the input string is in the language.
Equivalently, since our type theory is constructive, you can think of the result type as the type of concrete syntax trees which can result from parsing the input string.
\begin{remark}
Note that a language may admit multiple different proofs (or concrete syntax trees) for the same string. This is in constrast to the traditional set-theoretic definition which throws away the information about why the string
is in the language and only leaves the single bit of information that the string is or is not in the language.
\end{remark}
The above definition of language is broad; it includes languages that are not context-free.
\begin{example}\label{ex:non-context-free}
The language $a^n b^n c^n$ can be specified as follows:
\begin{code}[hide]%
%
\>[4]\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{Char}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{String}\<%
\\
%
\>[4]\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[4]\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{c}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{abc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaFunction{abc}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaString{'a'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaString{'b'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaFunction{repeat}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaString{'c'}\<%
\end{code}
We can show that the string $aabbcc$ is in this language by choosing $n$ to be $2$, from which the required equality follows by reflexivity after normalization:
\begin{code}%
%
\>[4]\AgdaFunction{aabbcc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{abc}\AgdaSpace{}%
\AgdaString{"aabbcc"}\<%
\\
%
\>[4]\AgdaFunction{aabbcc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}
\end{example}
\cref{ex:non-context-free} shows that it is possible to prove that certain strings are in a language manually, but for practical applications we do not want to be burdened with writing such proofs ourselves.
In other words, we want a parser which can determine by itself whether a string is in the language or not.

Unfortunately, we cannot hope to write a parser for arbitrary languages defined in this way. A language could be defined, for example, such that the inclusion of a particular string is predicated on whether or not the Collatz conjecture holds.
Therefore, we need to restrict ourselves to a subset of languages.
We explore basic language combinators for this purpose in the next section.

\subsection{Basic Language Combinators}

Let's start with a simple example: POSIX file system permissions. These are usually summarized using the characters `r', `w', and `x' if the permissions are granted, or `-' in place of the corresponding character if the permission is denied. For example the string ``r-x'' indicates that read and execute permissions are granted, but the write permission is denied. The full language can be expressed using the following grammar:
\begin{align*}
\langle\textit{permissions}\rangle & ::= \langle\textit{read}\rangle~\langle\textit{write}\rangle~\langle\textit{execute}\rangle \\
\langle\textit{read}\rangle & ::= - \mid \textrm{r} \\
\langle\textit{write}\rangle & ::= - \mid \textrm{w} \\
\langle\textit{execute}\rangle & ::= - \mid \textrm{x}
\end{align*}

\begin{code}[hide]%
%
\>[4]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{ℒ}\AgdaSpace{}%
\AgdaGeneralizable{ℒ₁}\AgdaSpace{}%
\AgdaGeneralizable{ℒ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\end{code}

\begin{figure}
\begin{minipage}{.63\textwidth}
\begin{code}%
%
\>[4]\AgdaOperator{\AgdaFunction{`\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Char}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaBound{c}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{w}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{++}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{v}\<%
\end{code}
\end{minipage}
\begin{minipage}{.36\textwidth}
\begin{code}%
%
\>[4]\AgdaFunction{∅}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaFunction{∅}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{ε}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaFunction{ε}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{w}\<%
\end{code}
\end{minipage}
\begin{code}[hide]%
%
\>[4]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{22}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{21}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∗\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{21}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{20}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪\AgdaUnderscore{}}}\<%
\end{code}
\caption{Basic language combinators.}\label{fig:combinators}
\end{figure}

This grammar uses three important features: sequencing, choice, and matching
character literals. We can define these features as combinators on languages in
Agda as shown in the left column of \cref{fig:combinators}. Using these
combinators we can define our permissions language as follows:
%
\begin{code}[hide]%
%
\>[4]\AgdaFunction{permissions}\AgdaSpace{}%
\AgdaFunction{read}\AgdaSpace{}%
\AgdaFunction{write}\AgdaSpace{}%
\AgdaFunction{execute}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{permissions}%
\>[17]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{read}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaFunction{write}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaFunction{execute}\<%
\\
%
\>[4]\AgdaFunction{read}%
\>[17]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'-'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'r'}\<%
\\
%
\>[4]\AgdaFunction{write}%
\>[17]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'-'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'w'}\<%
\\
%
\>[4]\AgdaFunction{execute}%
\>[17]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'-'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'x'}\<%
\end{code}

The right column of \cref{fig:combinators} lists combinators whose purpose will become clear when we discuss how to write parsers for this simple language in the next section.

\subsection{Parsers}

We want to write a program which can automatically prove for us whether or not a
given string is in a language. What should this program return for strings that
are not in the language? We want to make sure our program does find a proof if
it exists, so if it does not exist then we want a proof that the string is not
in the language. We can capture this using decidable types (\af{Dec}) from the Agda
standard library. It can be defined as follows:

% This type already exists in the stdlib so we give it a different name (but the ◂ is hidden)
\begin{code}%
%
\>[4]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{◂Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaInductiveConstructor{◂yes}%
\>[14]\AgdaSymbol{:}%
\>[19]\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{◂Dec}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[8]\AgdaInductiveConstructor{◂no}%
\>[14]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{¬}}%
\>[19]\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{◂Dec}\AgdaSpace{}%
\AgdaBound{A}\<%
\end{code}

A value of type $\af{Dec}~\ab{A}$ either witnesses that $\ab{A}$ is inhabited by constructing an inhabitant, or it proves that $\ab{A}$ is empty by showing how a hypothetical inhabitant of $\ab{A}$ leads to a contradiction.

We can prove the decidability of one type using the decidability of a related type if we have functions going both ways between the types.
For this purpose, the Agda standard library provides the $\af{map}~\as{:}~\ab{A}~\af{⇔}~\ab{B}~\af{→}~\af{Dec}~\ab{A}~\af{→}~\af{Dec}~\ab{B}$ function.
The $\af{⇔}$ type is an abstraction for having two functions going both way and can be constructed as such using the $\af{mk⇔}$ function.

A parser for a language, then, is a program which can tell us whether any given string is in the language or not.

\begin{code}%
%
\>[4]\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Type}\<%
\\
%
\>[4]\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\end{code}

\begin{remark}
Readers familiar with Haskell might notice the similarity between $\as{(}\ab{w}~\as{:}~\af{String}\as{)}~\as{→}~\af{Dec}~\as{(}\ab{P}~\ab{w}\as{)}$ and \verb|String -> Maybe a|, which is a common way to implement parser combinators (although usually the return type is \verb|Maybe (a, String)| giving parsers the freedom to consume only a prefix of the input string and return the rest).
The differences are that the result of our $\af{Parser}$ type depends on the language specification and input string, and that a failure carries with it a proof that the string cannot be part of the language.
This allows us to separate the specification of our language from the implementation while ensuring correctness.
\end{remark}

\begin{remark}
Note that the \af{Dec} type only requires our parsers to produce a single
result; it does not have to exhaustively list all possible ways to parse the
input string. In Haskell, one might write \verb|String -> [(a, String)]| following Hutton and Meijer~\cite{monadic-parsing}, which allows a parser to return
multiple results but does nothing to ensure that it correctly produces all
possible results.
If we wanted to capture all possible results in our Agda formalisation then we
could replace $\af{Dec}$ by a type which fixes the cardinality of the result
type fully.
However, we expect that would introduce many complications in our proofs.
In practice, furthermore, we want our parsers to only give us a single result.
Hence, our effort would be better spent in proving that our languages are
unambiguous, meaning there is at most one valid way to parse each input string.
Hence, we choose to use $\af{Dec}$ in this paper.
\end{remark}

To construct a parser for our permissions language, we start by defining parsers for each of the language combinators. Let us start by considering the character combinator. If the given string is empty or has more than one character, it can never be in a language formed by one character. If the string does consist of only one character, then it is in the language if that character is the same as from the language specification. In Agda, we can write such a parser for characters as follows:

\begin{code}%
%
\>[4]\AgdaOperator{\AgdaFunction{◂`-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Char}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{◂`-parse}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{◂`-parse}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{mk⇔}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\}))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{◂`-parse}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{(\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\end{code}

This is a correct implementation of a parser for languages that consist of a single character, but the implementation seems ad hoc and it is hard to read, especially considering this is one of the simpler combinators.

Following the approach of parsing with derivatives, we can factor this parser into two cases: the empty string case and the case with at least one character. Folowwing Elliott~\cite{conal-languages} and earlier work, we call the former nullability and denote it with the greek character $ν$ (not to be confused with greatest fixed points), and we call the latter derivative and denote it with the greek character $δ$. 

Crucially, nullability deals only with (decidable) types, and derivatives deal only with languages. This clearly separates the level of abstraction between both cases. 

Returning to our character parser, a single character language is not nullable. On the level of types we express this as $\af{⊥}$, the uninhabited type, which is trivially decidable as $\ac{no}~\as{λ}~\as{()}$.

The derivative of a single character language depends on whether the character
of the derivative is the same as the character of the language. We might be
tempted to define this condition externally in Agda, but that would break the
abstraction of derivatives only dealing with languages. Instead, we are pushed
toward defining a combinator, \af{\un{}·\un{}}, which allows us to express this
conditional on the level of languages. If the condition holds then there is
still a second condition which is that the remainder of the string needs to be
empty. We use the epsilon language, $\af{ε}$, for that purpose.
To conclude, the derivative of the character language $\af{`}~\ab{c'}$ with respect to the character $\ab{c}$ is $\as{(}\ab{c}~\af{≟}~\ab{c'}\as{)}~\af{·}~\af{ε}$ as shown in \cref{fig:null-delta}.

\begin{code}[hide]%
%
\>[4]\AgdaKeyword{variable}\AgdaSpace{}%
\AgdaGeneralizable{L}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\end{code}

\begin{code}[hide]%
%
\>[4]\AgdaFunction{⊥-dec}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\>[4]\AgdaFunction{⊥-dec}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{⊤-dec}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
%
\>[4]\AgdaFunction{⊤-dec}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\end{code}

\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{code}[hide]%
%
\>[4]\AgdaFunction{ν}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}◂⇔\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◂⇔}}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{ν∅}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{⊥}%
\>[23]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaFunction{∅}\<%
\\
%
\>[4]\AgdaFunction{νε}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{⊤}%
\>[23]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaFunction{ε}\<%
\\
%
\>[4]\AgdaFunction{ν·}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSymbol{)}%
\>[23]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{ν`}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{⊥}%
\>[23]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaGeneralizable{c'}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{ν∪}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}%
\>[23]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{ν∗}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}%
\>[23]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
\>[0]\<%
\end{code}
\end{minipage}
\begin{minipage}{0.54\textwidth}
\begin{code}[hide]%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[4]\AgdaFunction{δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Type}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Char}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{String}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{))}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟺\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaSymbol{(}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{w}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaBound{w}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{δ∅}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{∅}%
\>[27]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaFunction{∅}\<%
\\
%
\>[4]\AgdaFunction{δε}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{∅}%
\>[27]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaFunction{ε}\<%
\\
%
\>[4]\AgdaFunction{δ·}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSymbol{)}%
\>[27]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{δ`}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaGeneralizable{c'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaFunction{ε}\AgdaSymbol{)}%
\>[27]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaGeneralizable{c'}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{δ∪}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}%
\>[27]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{δ∗}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaFunction{δ}%
\>[683I]\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[683I]%
\>[27]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\end{code}
\end{minipage}
\caption{Nullability, derivatives, and how they relate to the basic combinators.}\label{fig:null-delta}
\end{figure}

\begin{code}[hide]%
%
\>[4]\AgdaFunction{ν∅}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\\
%
\>[4]\AgdaFunction{δ∅}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\end{code}

\begin{code}[hide]%
%
\>[4]\AgdaFunction{∅-parse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaFunction{∅}\<%
\\
%
\>[4]\AgdaFunction{∅-parse}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{ν∅}\AgdaSpace{}%
\AgdaFunction{⊥-dec}\<%
\\
%
\>[4]\AgdaFunction{∅-parse}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ∅}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{c}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{w}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∅-parse}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{νε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mk⇔}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
%
\>[4]\AgdaFunction{δε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mk⇔}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{())}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{())}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{ε-parse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaFunction{ε}\<%
\\
%
\>[4]\AgdaFunction{ε-parse}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{νε}\AgdaSpace{}%
\AgdaFunction{⊤-dec}\<%
\\
%
\>[4]\AgdaFunction{ε-parse}\AgdaSpace{}%
\AgdaSymbol{(\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{δε}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∅-parse}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{ν·}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\\
%
\>[4]\AgdaFunction{δ·}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·}}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[35]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν·}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×-dec}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSymbol{))}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[35]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ·}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·-parse}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{ν`}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mk⇔}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{())}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{())}\<%
\\
%
\>[4]\AgdaFunction{δ`}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mk⇔}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\end{code}


Furthermore, \cref{fig:null-delta} shows the nullability and derivatives of all basic combinators using simple and self-contained equivalances.
The implementation of parsers for our basic combinators follow completely from the decomposition into nullability and derivatives and these equivalances.
For example, we can rewrite our character parser as follows:
%
\begin{code}%
%
\>[4]\AgdaOperator{\AgdaFunction{`-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Char}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaBound{c'}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[26]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{ν`}\AgdaSpace{}%
\AgdaFunction{⊥-dec}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaBound{c'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[26]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{δ`}\AgdaSpace{}%
\AgdaSymbol{(((}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟}}\AgdaSpace{}%
\AgdaBound{c'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·-parse}}\AgdaSpace{}%
\AgdaFunction{ε-parse}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\end{code}

Parsers for the other basic combinators are similarly straightforward.

\begin{code}[hide]%
%
\>[4]\AgdaFunction{ν∪}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\\
%
\>[4]\AgdaFunction{δ∪}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇔.refl}\<%
\end{code}

\begin{code}[hide]%
%
\>[4]\AgdaComment{--\ To\ make\ this\ work\ properly\ we\ have\ to\ do\ some\ ugly\ implicit\ parameter\ manipulation}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[35]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν∪}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[35]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ∪}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{c}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaFunction{◂ν∪}%
\>[13]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{⊎}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}%
\>[28]\AgdaOperator{\AgdaFunction{⇔}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\<%
\\
%
\>[8]\AgdaFunction{◂ν∪}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{ν∪}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\}}\<%
\\
%
\>[8]\AgdaFunction{◂δ∪}%
\>[13]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}%
\>[32]\AgdaOperator{\AgdaFunction{⟺}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaGeneralizable{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\<%
\\
%
\>[8]\AgdaFunction{◂δ∪}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{δ∪}\AgdaSpace{}%
\AgdaSymbol{\{\AgdaUnderscore{}\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Q}\AgdaSymbol{\}}\<%
\end{code}
\begin{code}[hide]%
%
\>[8]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}◂∪-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaBound{Q}\AgdaSymbol{)}\<%
\\
%
\>[8]\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◂∪-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[32]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{◂ν∪}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\<%
\\
%
\>[8]\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◂∪-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[32]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{◂δ∪}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\end{code}

\begin{code}[hide]%
%
\>[4]\AgdaFunction{ν∗}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mk⇔}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{\})}\<%
\\
%
\>[4]\AgdaFunction{δ∗}%
\>[991I]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mk⇔}\<%
\\
\>[991I][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[10]\AgdaSymbol{(}\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\>[8]\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[10]\AgdaSymbol{(\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{u}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\end{code}

\begin{code}[hide]%
%
\>[4]\AgdaFunction{map′-id-id}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaGeneralizable{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Dec.map′}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[4]\AgdaFunction{map′-id-id}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[4]\AgdaFunction{map′-id-id}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[4]\AgdaFunction{∪-parse-rewrite}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀\{}\AgdaBound{φ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ψ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{w}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaGeneralizable{w}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSpace{}%
\AgdaGeneralizable{w}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{∪-parse-rewrite}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{map′-id-id}\<%
\\
%
\>[4]\AgdaFunction{∪-parse-rewrite}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSpace{}%
\AgdaFunction{map′-id-id}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∪-parse-rewrite}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{\})}\<%
\end{code}

\begin{code}[hide]%
%
\>[4]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{22}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`-parse\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{21}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∗-parse\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{21}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·-parse\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{20}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∪-parse\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaComment{--\ To\ convince\ Agda\ this\ terminates,\ we\ need\ to\ use\ the\ identity:}\<%
\\
%
\>[4]\AgdaComment{--\ (φ\ ∪-parse\ ψ)\ w\ ≡\ φ\ w\ ⊎-dec\ ψ\ w}\<%
\\
%
\>[4]\AgdaComment{--\ That\ is\ easy\ to\ prove\ (see\ ∪-parse-rewrite\ above),\ but\ convincing\ Agda\ to\ use\ this\ is\ a\ bit\ difficult}\<%
\\
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∗-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[27]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{ν∗}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×-dec}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[27]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{δ∗}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·-parse}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊎-dec}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaComment{--\ So\ we\ just\ use\ the\ TERMINATING\ pragma\ for\ the\ code\ that\ we\ show\ in\ the\ paper.}\<%
\\
%
\>[4]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{TERMINATING}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
\begin{code}[hide]%
%
\>[4]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}◂∗-parse\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaGeneralizable{Q}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◂∗-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}%
\>[28]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{ν∗}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×-dec}}\AgdaSpace{}%
\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{◂∗-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{c}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}%
\>[28]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Dec.map}\AgdaSpace{}%
\AgdaFunction{δ∗}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{ν}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·-parse}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaFunction{δ}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{φ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗-parse}}\AgdaSpace{}%
\AgdaBound{ψ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{w}\AgdaSymbol{)}\<%
\end{code}

The parser for our full permissions language can now be implemented by simply
mapping each of the language combinators onto their respective parser
combinators.
%
\begin{code}[hide]%
%
\>[4]\AgdaFunction{permissions-parse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaFunction{permissions}\<%
\\
%
\>[4]\AgdaFunction{read-parse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaFunction{read}\<%
\\
%
\>[4]\AgdaFunction{write-parse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaFunction{write}\<%
\\
%
\>[4]\AgdaFunction{execute-parse}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Parser}\AgdaSpace{}%
\AgdaFunction{execute}\<%
\end{code}
\begin{code}%
%
\>[4]\AgdaFunction{permissions-parse}%
\>[23]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{read-parse}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗-parse}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{write-parse}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗-parse}}\AgdaSpace{}%
\AgdaFunction{execute-parse}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{read-parse}%
\>[23]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaString{'-'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaString{'r'}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{write-parse}%
\>[23]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaString{'-'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaString{'w'}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{execute-parse}%
\>[23]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaString{'-'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪-parse}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{`-parse}}\AgdaSpace{}%
\AgdaString{'x'}\AgdaSymbol{)}\<%
\end{code}
%
This allows us to generate a parser for any language that is defined using the basic combinators from \cref{fig:combinators}. We mechanize this result later in \cref{sec:parsing-in-general}, but we first consider extending the expressivity of our combinators.

\subsection{Infinite Languages}

This permissions language is very simple. In particular, it is finite. In practice, many languages are inifinite, for which the basic combinators will not suffice. For example, file paths can be arbitrarily long on most systems.
Elliott~\cite{conal-languages} defines a Kleene star combinator which enables him to specify regular languages such as file paths.

However, we want to go one step further, specifying and parsing context-free
languages. Most practical programming languages are at least context-free, if
not even more complicated. An essential feature of many languages is the ability
to recognize balanced brackets. A minimal example language with balanced
brackets is the following:
%
\begin{equation*}
\langle\textit{brackets}\rangle ::= ε \mid \textrm{[}~\langle\textit{brackets}\rangle~\textrm{]} \mid \langle\textit{brackets}\rangle~\langle\textit{brackets}\rangle
\end{equation*}
%
This is the language of all strings which consist of balanced square brackets. 
It is common for programming languages to include some form of balanced
brackets. Furthermore, this language is well known to be context-free and not
regular. Thus, we need more powerful combinators.

We could try to naively transcribe the brackets grammar using our basic combinators, but Agda will justifiably complain that it is not terminating. Here we have added a NON_TERMINATING pragma to make Agda to accept it anyway, but this is obviously not the proper way to define our brackets language.
%
\begin{code}%
%
\>[4]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{NON\AgdaUnderscore{}TERMINATING}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\>[4]\AgdaFunction{brackets}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'['}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaFunction{brackets}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{']'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaFunction{brackets}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaFunction{brackets}\<%
\end{code}
%
We need to find a different way to encode this recursive relation.
A fixed point combinator could resolve this issue as follows:
\begin{code}%
%
\>[4]\AgdaKeyword{postulate}\AgdaSpace{}%
\AgdaPostulate{μ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Lang}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Lang}\<%
\\
%
\>[4]\AgdaFunction{bracketsμ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{μ}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{'['}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{`}}\AgdaSpace{}%
\AgdaString{']'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∪}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∗}}\AgdaSpace{}%
\AgdaBound{P}\AgdaSymbol{)}\<%
\end{code}

Unfortunately, such a fixed point combinator does not exists for arbitrary
functions on languages. Luckily, we will see in the next section that we can
define such a fixed point combinator if we restrict the class of functions of which we take the fixed point.

\endinput

% % For starters, we define some structure on this definition of language in
% % \cref{fig:combinators}. First, Languages form a semiring, with union
% % $\af{\un{}∪\un{}}$, concatenation $\af{\un{}∗\un{}}$, the empty language
% % $\af{∅}$ which is the unit of union, and the language which only includes the
% % empty string $\af{ε}$ which is the unit of concatenation. Furthermore the
% % $\af{`\un}$ combinator defines a language which contains exactly the string
% % consisting of a single given character. Finally, the scalar multiplication
% % $\af{\un{}·\un{}}$ combinator injects an Agda type into a language. The purpose
% % of this combinator will become clearer in later sections\jr{mention specific sections}.
% 
% % \subsection{Decidability}
% 
% % From our type theoretic perspective, parsing a string is the same thing as producing an element of the result type of a language for that given input string, or showing that no such element can exist. In Agda, we encode this using the following \af{Dec} data type which is parameterized by a type \ab{A} and contains a constructor \ac{yes} for when you can produce an element of \ab{A} or \ac{no} if you can show that no such element exists.
% % \begin{code}
% % data Dec (A : Type) : Type where
%     % yes : A → Dec A
%     % no : (A → ⊥) → Dec A
% % \end{code}
% % Sometimes we want to change the parameter type of a \af{Dec}. For that we need to provide conversion functions between the old and the new type in both ways.
% % \begin{code}
% % map? : (A ↔ B) → Dec A → Dec B
% % map? f (yes x) = yes (to f x)
% % map? f (no ¬A) = no λ x → ¬A (from f x)
% % \end{code}
% % \begin{code}[hide]
% % ⌊_⌋ : Dec A → Type
% % ⌊_⌋ {A} _ = A
% 
% % _×?_ : Dec A → Dec B → Dec (A × B)
% % yes x ×? yes y = yes (x , y)
% % yes _ ×? no ¬y = no λ (_ , y) → ¬y y
% % no ¬x ×? _ = no λ (x , _) → ¬x x
% 
% % _⊎?_ : Dec A → Dec B → Dec (A ⊎ B)
% % yes x ⊎? y = yes (inl x)
% % no x ⊎? yes y = yes (inr y)
% % no ¬x ⊎? no ¬y = no λ where
%     % (inl x) → ¬x x
%     % (inr y) → ¬y y
% 
% % _≟_ : (c : Char) → (c′ : Char) → Dec (c ≡ c′)
% % `a ≟ `a = yes refl
% % `a ≟ `b = no λ ()
% % `a ≟ `c = no λ ()
% % `a ≟ `0 = no λ ()
% % `a ≟ `1 = no λ ()
% % `b ≟ `a = no λ ()
% % `b ≟ `b = yes refl
% % `b ≟ `c = no λ ()
% % `b ≟ `0 = no λ ()
% % `b ≟ `1 = no λ ()
% % `c ≟ `a = no λ ()
% % `c ≟ `b = no λ ()
% % `c ≟ `c = yes refl
% % `c ≟ `0 = no λ ()
% % `c ≟ `1 = no λ ()
% % `0 ≟ `a = no λ ()
% % `0 ≟ `b = no λ ()
% % `0 ≟ `c = no λ ()
% % `0 ≟ `0 = yes refl
% % `0 ≟ `1 = no λ ()
% % `1 ≟ `a = no λ ()
% % `1 ≟ `b = no λ ()
% % `1 ≟ `c = no λ ()
% % `1 ≟ `0 = no λ ()
% % `1 ≟ `1 = yes refl
% % `a ≟ `[ = no λ ()
% % `a ≟ `] = no λ ()
% % `b ≟ `[ = no λ ()
% % `b ≟ `] = no λ ()
% % `c ≟ `[ = no λ ()
% % `c ≟ `] = no λ ()
% % `0 ≟ `[ = no λ ()
% % `0 ≟ `] = no λ ()
% % `1 ≟ `[ = no λ ()
% % `1 ≟ `] = no λ ()
% % `[ ≟ `a = no λ ()
% % `[ ≟ `b = no λ ()
% % `[ ≟ `c = no λ ()
% % `[ ≟ `0 = no λ ()
% % `[ ≟ `1 = no λ ()
% % `[ ≟ `[ = yes refl
% % `[ ≟ `] = no λ ()
% % `] ≟ `a = no λ ()
% % `] ≟ `b = no λ ()
% % `] ≟ `c = no λ ()
% % `] ≟ `0 = no λ ()
% % `] ≟ `1 = no λ ()
% % `] ≟ `[ = no λ ()
% % `] ≟ `] = yes refl
% 
% % \end{code}
% 
% \subsection{Grammars}\label{sec:gram-and-parsing}
% 
% We have seen in \cref{ex:non-context-free} that our definition of language is very general, comprising even context-sensitive languages. Parsing such languages automatically poses a significant challenge. Hence, we side-step this problem by restricting the scope of our parsers to a smaller well-defined subset of languages. In this subsection, we consider a subset of regular languages without Kleene star (i.e., closure under concatenation). In \cref{sec:context-free}, we extend this class of languages to include fixed points which subsume the Kleene star.
% 
% \begin{code}[hide]
% module ◆ where
% \end{code}
% \begin{code}
%     data Exp : Type₁ where
%         ∅ : Exp
%         ε : Exp
%         `_ : (c : Char) → Exp
%         _·_ : {A : Type} → Dec A → Exp → Exp
%         _∪_ : Exp → Exp → Exp
%         _∗_ : Exp → Exp → Exp
% \end{code}
% 
% This syntax maps directly onto the semantics we defined in \cref{fig:combinators}.
% 
% \begin{code}[hide]
%     typeOfDec : {A : Type} → Dec A → Type
%     typeOfDec {A} _ = A
% \end{code}
% \begin{code}
%     ⟦_⟧ : Exp → Lang
%     ⟦ ∅ ⟧ = ◇.∅
%     ⟦ ε ⟧ = ◇.ε
%     ⟦ ` c ⟧ = ◇.` c
%     ⟦ x · e ⟧ = typeOfDec x ◇.· ⟦ e ⟧
%     ⟦ e ∪ e₁ ⟧ = ⟦ e ⟧ ◇.∪ ⟦ e₁ ⟧
%     ⟦ e ∗ e₁ ⟧ = ⟦ e ⟧ ◇.∗ ⟦ e₁ ⟧
% \end{code}
% 
% \subsection{Parsing}
% 
% To facilitate proving the inclusion of strings in a language, we start by decomposing the problem. A string is either empty or a character followed by the tail of the string. We can decompose the problem of string inclusion along the same dimensions. First, we define nullability $ν$ as the inclusion of the empty string in a language as follows:
% \begin{code}
%     ◇ν : Lang → Type
%     ◇ν ℒ = ℒ []
% \end{code}
% Second, we define the derivative $δ$ of a language $ℒ$ with respect to the character $c$ to be all the suffixes of the words in $ℒ$ which start with the $c$.
% \begin{code}
%     ◇δ : Char → Lang → Lang
%     ◇δ c ℒ = λ w → ℒ (c ∷ w)
% \end{code}
% The relevance of these definitions is shown by \cref{thm:nullability-after-derivatives}.
% \begin{theorem}\label{thm:nullability-after-derivatives}
% Nullability after repeated derivatives fully captures what a language is. Formally, we state this as follows:
% \begin{code}[hide]
%     ν∘foldlδℒ≡ℒ :
% \end{code}
% \begin{code}
%         ◇ν ∘ foldl ◇δ ℒ ≡ ℒ
% \end{code}
% \begin{code}[hide]
%     ν∘foldlδℒ≡ℒ′ : (ℒ : Lang) (w : String) → ◇ν (foldl ◇δ ℒ w) ≡ ℒ w
%     ν∘foldlδℒ≡ℒ′ ℒ [] = refl
%     ν∘foldlδℒ≡ℒ′ ℒ (c ∷ w) = ν∘foldlδℒ≡ℒ′ (◇δ c ℒ) w
% 
%     postulate funext : {ℓ₁ ℓ₂ : Level} {A : Set ℓ₁} {B : Set ℓ₂} {P Q : A → B} → ((x : A) → P x ≡ Q x) → P ≡ Q
% 
%     ν∘foldlδℒ≡ℒ {ℒ = ℒ} = funext (ν∘foldlδℒ≡ℒ′ ℒ)
% \end{code}
% \end{theorem}
% 
% \begin{code}
%     ν : (e : Exp) → Dec (◇ν ⟦ e ⟧)
%     δ : Char → Exp → Exp
%     δ-sound : ∀ e → ⟦ δ c e ⟧ w → ◇δ c ⟦ e ⟧ w
%     δ-complete : ∀ e → ◇δ c ⟦ e ⟧ w → ⟦ δ c e ⟧ w
% \end{code}
% 
% \begin{code}[hide]
%     map' : ∀{A B} → (A → B) → (B → A) → Dec A → Dec B
%     map' = map′
% \end{code}
% \begin{code}
%     parse : (e : Exp) (w : String) → Dec (⟦ e ⟧ w)
%     parse e [] = ν e
%     parse e (c ∷ w) = map' (δ-sound e) (δ-complete e) (parse (δ c e) w)
% \end{code}
% 
% \subsection{Nullability}
% 
% \begin{lemma}
% Two languages, $\ab{ℒ₁}$ and $\ab{ℒ₂}$, are nullable if and only if their concatenation, $\ab{ℒ₁}~\af{◇.∗}~\ab{ℒ₂}$, is nullable. 
% \begin{code}
%     ν∗ : (◇ν ℒ₁ × ◇ν ℒ₂) ⇔ ◇ν (ℒ₁ ◇.∗ ℒ₂)
% \end{code}
% \begin{code}[hide]
%     ν∗ = mk⇔ (λ x → [] , [] , refl , x) λ { ([] , [] , refl , x) → x }
% \end{code}
% \end{lemma}
% 
% \begin{code}
%     ν ∅ = no λ ()
%     ν ε = yes refl
%     ν (` c) = no λ ()
%     ν (x · e) = x ×-dec ν e 
%     ν (e ∪ e₁) = ν e ⊎-dec ν e₁
%     ν (e ∗ e₁) = Dec.map ν∗ (ν e ×-dec ν e₁)
% \end{code}
% 
% \subsection{Derivation}
% 
% \begin{code}
%     δ c ∅ = ∅
%     δ c ε = ∅
%     δ c (` c₁) = (c ≟ c₁) · ε -- a bit interesting
%     δ c (x · e) = x · δ c e
%     δ c (e ∪ e₁) = δ c e ∪ δ c e₁
%     δ c (e ∗ e₁) = (δ c e ∗ e₁) ∪ (ν e · δ c e₁) -- interesting
% \end{code}
% 
% The proofs are very straightforward:
% 
% \begin{code}
%     δ-sound (` c) (refl , refl) = refl
%     δ-sound (x₁ · e) (x , y) = x , δ-sound e y
%     δ-sound (e ∪ e₁) (inj₁ x) = inj₁ (δ-sound e x)
%     δ-sound (e ∪ e₁) (inj₂ y) = inj₂ (δ-sound e₁ y)
%     δ-sound (e ∗ e₁) (inj₁ (u , v , refl , x , y)) = _ ∷ u , v , refl , δ-sound e x , y
%     δ-sound (e ∗ e₁) (inj₂ (x , y)) = [] , _ , refl , x , δ-sound e₁ y
% \end{code}
% 
% \begin{code}
%     δ-complete (` c) refl = refl , refl
%     δ-complete (x₁ · e) (x , y) = x , δ-complete e y
%     δ-complete (e ∪ e₁) (inj₁ x) = inj₁ (δ-complete e x)
%     δ-complete (e ∪ e₁) (inj₂ y) = inj₂ (δ-complete e₁ y)
%     δ-complete (e ∗ e₁) (_ ∷ _ , _ , refl , x , y) = inj₁ (_ , _ , refl , δ-complete e x , y)
%     δ-complete (e ∗ e₁) ([] , _ , refl , x , y) = inj₂ (x , δ-complete e₁ y)
% \end{code}
% 
% % \begin{code}[hide]
% % module Simple where
% % \end{code}
% % \begin{code}
% %     data Gram : Lang → Type₁ where
% %         ∅     :                       Gram (λ _ → ⊥)
% %         ε     :                       Gram (λ w → w ≡ [])
% %         char  : (c : Char)         →  Gram (λ w → w ≡ c ∷ [])
% %         _·_   : Dec A → Gram ℒ     →  Gram (λ w → A × ℒ w)
% %         _∪_   : Gram ℒ₁ → Gram ℒ₂  →  Gram (λ w → ℒ₁ w ⊎ ℒ₂ w)
% %         _∗_   : Gram ℒ₁ → Gram ℒ₂
% %               → Gram (λ w → Σ String λ u → Σ String λ v → (w ≡ u ++ v) × ℒ₁ u × ℒ₂ v)
% %         _◃_   : (ℒ₁ ⇔ ℒ₂) → Gram ℒ₁ → Gram ℒ₂
% % \end{code}
% % \begin{code}[hide]
% %     variable G G₁ G₂ : Gram ℒ
% % \end{code}
% % \begin{remark}
% % The \af{Gram} data type is parameterized by its language. This ties the constructors directly to their semantics.
% % \end{remark}
% % 
% % By recursion over this data type of grammars, we can define a decision procedure for nullability and derivative function; both are correct by construction.
% % \begin{code}
% %     ν? : Gram ℒ → Dec (ν ℒ)
% %     δ? : Gram ℒ → (c : Char) → Gram (δ ℒ c)
% % \end{code}
% % \begin{code}[hide]
% %     ν∗ : (ν ℒ₁ × ν ℒ₂) ↔ Σ String λ u → Σ String λ v → ([] ≡ (u ++ v)) × ℒ₁ u × ℒ₂ v
% %     to ν∗ (x , y) = [] , [] , refl , x , y
% %     from ν∗ ([] , [] , refl , x , y) = x , y
% % 
% %     ν? ∅ = no λ ()
% %     ν? ε = yes refl
% %     ν? (char c) = no λ ()
% %     ν? (x · G) = x ×? ν? G
% %     ν? (G₁ ∪ G₂) = ν? G₁ ⊎? ν? G₂
% %     ν? (G₁ ∗ G₂) = map? ν∗ (ν? G₁ ×? ν? G₂)
% %     ν? (f ◃ G₂) = map? f (ν? G₂)
% % \end{code}
% % \begin{code}[hide]
% %     δ? ∅ c = ∅
% %     δ? ε c = record { to = λ () ; from = λ () } ◃ ∅
% %     δ? (char c′) c with c ≟ c′
% %     ... | yes refl = (λ { {[]} → record { to = λ _ → refl ; from = λ _ → refl } ; {_ ∷ _} → record { to = λ () ; from = λ () }}) ◃ ε
% %     ... | no ¬c≡c′ = (λ { {[]} → record { to = λ () ; from = λ { refl → ¬c≡c′ refl }} ; {_ ∷ _} → record { to = λ () ; from = λ () }}) ◃ ∅
% %     δ? (A · G) c = A · δ? G c
% %     δ? (G₁ ∪ G₂) c = δ? G₁ c ∪ δ? G₂ c
% %     δ? (G₁ ∗ G₂) c = (record { to = λ { (inl (u , v , refl , x , y)) → (c ∷ u) , v , refl , x , y ; (inr (x , y)) → [] , (c ∷ _) , refl , x , y } ; from = λ { ([] , _ , refl , x , y) → inr (x , y) ; ((_ ∷ u) , v , refl , x , y) → inl (u , v , refl , x , y) } } ) ◃ ((δ? G₁ c ∗ G₂) ∪ (ν? G₁ · δ? G₂ c))
% %     δ? (f ◃ G₂) c = f ◃ δ? G₂ c
% % 
% %     -- δ?↔δ : ⟦ δ? c G ⟧ w ↔ δ c ⟦ G ⟧ w
% % \end{code}
% % \begin{code}[hide]
% %     -- to (δ?↔δ {c} {G = ` c′}) x with c ≟ c′
% %     -- to (δ?↔δ {c} {` .c}) refl | yes refl = refl
% %     -- to (δ?↔δ {_} {` _}) () | no _
% %     -- to (δ?↔δ {G = A · G}) (x , y) = x , to δ?↔δ y
% %     -- to (δ?↔δ {G = G₁ ∪ G₂}) (inl x) = inl (to δ?↔δ x)
% %     -- to (δ?↔δ {G = G₁ ∪ G₂}) (inr x) = inr (to δ?↔δ x)
% %     -- to (δ?↔δ {c} {G = G₁ ▹ G₂}) (inl (u , v , refl , x , y)) = (c ∷ u) , v , refl , to δ?↔δ x , y
% %     -- to (δ?↔δ {c} {G = G₁ ▹ G₂} {w}) (inr (π₁ , π₂)) = [] , (c ∷ w) , refl , π₁ , to δ?↔δ π₂
% %     -- from (δ?↔δ {c} {G = ` c′}) x with c ≟ c′
% %     -- from (δ?↔δ {c} {` c}) refl | yes refl = refl
% %     -- from (δ?↔δ {c} {` .c}) refl | no ¬c≡c = ¬c≡c refl
% %     -- from (δ?↔δ {G = A · G}) (π₁ , π₂) = π₁ , from δ?↔δ π₂
% %     -- from (δ?↔δ {G = G ∪ G₁}) (inl x) = inl (from δ?↔δ x)
% %     -- from (δ?↔δ {G = G ∪ G₁}) (inr x) = inr (from δ?↔δ x)
% %     -- from (δ?↔δ {c} {G = G ▹ G₁}) ([] , (.c ∷ v) , refl , x , y) = inr (x , from δ?↔δ y)
% %     -- from (δ?↔δ {c} {G = G ▹ G₁}) ((.c ∷ u) , v , refl , x , y) = inl (u , v , refl , from δ?↔δ x , y)
% %     transport : {ℓ₁ : Level} {A : Set ℓ₁} {B : Set ℓ₁} → A ≡ B → A → B
% %     transport refl x = x
% % \end{code}
% % Together, decidable nullability and the derivative function can be combined to decide whether any string is in the language described by a grammar.
% % \begin{code}
% %     parse : Gram ℒ → (w : String) → Dec (ℒ w)
% %     parse G [] = ν? G
% %     parse G (c ∷ w) = parse (δ? G c) w
% % \end{code}
% % Thus, we have defined a parser for our simple grammars.
% 
% % A language is a set of strings $\mathbb{2}^{(\af{List}~\af{Token})}$.
% % 
% % 
% % \begin{code}[hide]
% % Lang : Set₁
% % \end{code}
% % \begin{code}
% % Lang = List Token → Set
% % \end{code}
% % 
% % This type has a very rich structure. It forms an ... algebra with union and intersection and a semiring with union and sequential composition.
% % 
% % \begin{code}
% % ∅ : Lang
% % ∅ _ = ⊥
% % \end{code}
% % 
% % Going beyond work by Elliott, we can try to define context-free grammars.
% % Unfortunately, we quickly run into issues due to nontermination. It is not easy
% % to show that a grammar defined in this way is well-founded. To solve this issue
% % we can use guarded type theory, in our case provided by guarded cubical Agda.
% % This allows us to define arbitrary fixed points of languages.
% % 
% % \begin{code}
% % fueled : (Lang → Lang) → ℕ → Lang
% % fueled f 0 = ∅
% % fueled f (suc n) = f (fueled f n)
% % \end{code}
% % 
% % \begin{code}
% % fix : (Lang → Lang) → Lang
% % fix f w = ∃[ n ] fueled f n w
% % \end{code}
% 