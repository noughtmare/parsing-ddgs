@article{monadic-parsing, title={Monadic parsing in Haskell}, volume={8}, DOI={10.1017/S0956796898003050}, number={4}, journal={Journal of Functional Programming}, author={Hutton, Graham and Meijer, Erik}, year={1998}, pages={437–444}}

@techreport{parsec,
author = {Leijen, Daan and Meijer, Erik},
title = {Parsec: Direct Style Monadic Parser Combinators for the Real World},
year = {2001},
month = {July},
abstract = {Despite the long list of publications on parser combinators, there does not yet exist a monadic parser combinator library that is applicable in real world situations. In particular naive implementations of parser combinators are likely to suffer from space leaks and are often unable to report precise error messages in case of parse errors. The Parsec parser combinator library described in this paper, utilizes a novel implementation technique for space and time efficient parser combinators that in case of a parse error, report both the position of the error as well as all grammar productions that would have been legal at that point in the input.},
url = {https://www.microsoft.com/en-us/research/publication/parsec-direct-style-monadic-parser-combinators-for-the-real-world/},
edition = {Technical Report UU-CS-2001-35, Departement of Computer Science, Universiteit Utrecht},
number = {UU-CS-2001-27},
note = {User Modeling 2007, 11th International Conference, UM 2007, Corfu, Greece, June 25-29, 2007},
}

@incollection{combinator-parsing-short-tutorial,
  title={Combinator parsing: A short tutorial},
  author={Swierstra, S Doaitse},
  booktitle={International LerNet ALFA Summer School on Language Engineering and Rigorous Software Development},
  pages={252--300},
  year={2008},
  publisher={Springer}
}

@inproceedings{design-patterns-for-parser-combinators,
author = {Willis, Jamie and Wu, Nicolas},
title = {Design patterns for parser combinators (functional pearl)},
year = {2021},
isbn = {9781450386159},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/3471874.3472984},
doi = {10.1145/3471874.3472984},
abstract = {Parser combinators are a popular and elegant approach for parsing in functional languages. The design and implementation of such libraries are well discussed, but having a well-designed library is only one-half of the story. In this paper we explore several reusable approaches to writing parsers in combinator style, focusing on easy to apply patterns to keep parsing code simple, separated, and maintainable.},
booktitle = {Proceedings of the 14th ACM SIGPLAN International Symposium on Haskell},
pages = {71–84},
numpages = {14},
keywords = {parser combinators},
location = {Virtual, Republic of Korea},
series = {Haskell 2021}
}

@inproceedings{one-parser-to-rule-them-all,
author = {Afroozeh, Ali and Izmaylova, Anastasia},
title = {One parser to rule them all},
year = {2015},
isbn = {9781450336888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/2814228.2814242},
doi = {10.1145/2814228.2814242},
abstract = {Despite the long history of research in parsing, constructing parsers for real programming languages remains a difficult and painful task. In the last decades, different parser generators emerged to allow the construction of parsers from a BNF-like specification. However, still today, many parsers are handwritten, or are only partly generated, and include various hacks to deal with different peculiarities in programming languages. The main problem is that current declarative syntax definition techniques are based on pure context-free grammars, while many constructs found in programming languages require context information. In this paper we propose a parsing framework that embraces context information in its core. Our framework is based on data-dependent grammars, which extend context-free grammars with arbitrary computation, variable binding and constraints. We present an implementation of our framework on top of the Generalized LL (GLL) parsing algorithm, and show how common idioms in syntax of programming languages such as (1) lexical disambiguation filters, (2) operator precedence, (3) indentation-sensitive rules, and (4) conditional preprocessor directives can be mapped to data-dependent grammars. We demonstrate the initial experience with our framework, by parsing more than 20000 Java, C#, Haskell, and OCaml source files.},
booktitle = {2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward!)},
pages = {151–170},
numpages = {20},
keywords = {GLL, Parsing, context-aware scanning, data-dependent grammars, disambiguation, offside rule, operator precedence, preprocessor directives, scannerless parsing},
location = {Pittsburgh, PA, USA},
series = {Onward! 2015}
}

@inproceedings{general-parser-combinators,
author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs van der},
title = {Practical, general parser combinators},
year = {2016},
isbn = {9781450340977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/2847538.2847539},
doi = {10.1145/2847538.2847539},
abstract = {Parser combinators are a popular approach to parsing where context-free grammars are represented as executable code. However, conventional parser combinators do not support left recursion, and can have worst-case exponential runtime. These limitations hinder the expressivity and performance predictability of parser combinators when constructing parsers for programming languages. In this paper we present general parser combinators that support all context-free grammars and construct a parse forest in cubic time and space in the worst case, while behaving nearly linearly on grammars of real programming languages. Our general parser combinators are based on earlier work on memoized Continuation-Passing Style (CPS) recognizers. First, we extend this work to achieve recognition in cubic time. Second, we extend the resulting cubic CPS recognizers to parsers that construct a binarized Shared Packed Parse Forest (SPPF). Our general parser combinators bring the best of both worlds: the flexibility and extensibility of conventional parser combinators and the expressivity and performance guarantees of general parsing algorithms. We used the approach presented in this paper as the basis for Meerkat, a general parser combinator library for Scala.},
booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
pages = {1–12},
numpages = {12},
keywords = {Parser combinators, continuation-passing style, general parsing, higher-order functions, left recursion, memoization},
location = {St. Petersburg, FL, USA},
series = {PEPM '16}
}

@article{brzozowski,
author = {Brzozowski, Janusz A.},
title = {Derivatives of Regular Expressions},
year = {1964},
issue_date = {Oct. 1964},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {11},
number = {4},
issn = {0004-5411},
dontuseurl = {https://doi.org/10.1145/321239.321249},
doi = {10.1145/321239.321249},
journal = {J. ACM},
month = oct,
pages = {481–494},
numpages = {14}
}

@article{10.1145/2034574.2034801,
author = {Might, Matthew and Darais, David and Spiewak, Daniel},
title = {Parsing with derivatives: a functional pearl},
year = {2011},
issue_date = {September 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {9},
issn = {0362-1340},
dontuseurl = {https://doi.org/10.1145/2034574.2034801},
doi = {10.1145/2034574.2034801},
abstract = {We present a functional approach to parsing unrestricted context-free grammars based on Brzozowski's derivative of regular expressions. If we consider context-free grammars as recursive regular expressions, Brzozowski's equational theory extends without modification to context-free grammars (and it generalizes to parser combinators). The supporting actors in this story are three concepts familiar to functional programmers - laziness, memoization and fixed points; these allow Brzozowski's original equations to be transliterated into purely functional code in about 30 lines spread over three functions.Yet, this almost impossibly brief implementation has a drawback: its performance is sour - in both theory and practice. The culprit? Each derivative can double the size of a grammar, and with it, the cost of the next derivative.Fortunately, much of the new structure inflicted by the derivative is either dead on arrival, or it dies after the very next derivative. To eliminate it, we once again exploit laziness and memoization to transliterate an equational theory that prunes such debris into working code. Thanks to this compaction, parsing times become reasonable in practice.We equip the functional programmer with two equational theories that, when combined, make for an abbreviated understanding and implementation of a system for parsing context-free languages.},
journal = {SIGPLAN Not.},
month = sep,
pages = {189–195},
numpages = {7},
keywords = {regular expressions, parsing, parser combinator, formal languages, derivative, context-free grammar}
}

@inproceedings{parsing-with-derivatives,
author = {Might, Matthew and Darais, David and Spiewak, Daniel},
title = {Parsing with derivatives: a functional pearl},
year = {2011},
isbn = {9781450308656},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/2034773.2034801},
doi = {10.1145/2034773.2034801},
abstract = {We present a functional approach to parsing unrestricted context-free grammars based on Brzozowski's derivative of regular expressions. If we consider context-free grammars as recursive regular expressions, Brzozowski's equational theory extends without modification to context-free grammars (and it generalizes to parser combinators). The supporting actors in this story are three concepts familiar to functional programmers - laziness, memoization and fixed points; these allow Brzozowski's original equations to be transliterated into purely functional code in about 30 lines spread over three functions.Yet, this almost impossibly brief implementation has a drawback: its performance is sour - in both theory and practice. The culprit? Each derivative can double the size of a grammar, and with it, the cost of the next derivative.Fortunately, much of the new structure inflicted by the derivative is either dead on arrival, or it dies after the very next derivative. To eliminate it, we once again exploit laziness and memoization to transliterate an equational theory that prunes such debris into working code. Thanks to this compaction, parsing times become reasonable in practice.We equip the functional programmer with two equational theories that, when combined, make for an abbreviated understanding and implementation of a system for parsing context-free languages.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Functional Programming},
pages = {189–195},
numpages = {7},
keywords = {regular expressions, parsing, parser combinator, formal languages, derivative, context-free grammar},
location = {Tokyo, Japan},
series = {ICFP '11}
}

@article{conal-languages,
author = {Elliott, Conal},
title = {Symbolic and automatic differentiation of languages},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
dontuseurl = {https://doi.org/10.1145/3473583},
doi = {10.1145/3473583},
abstract = {Formal languages are usually defined in terms of set theory. Choosing type theory instead gives us languages as type-level predicates over strings. Applying a language to a string yields a type whose elements are language membership proofs describing how a string parses in the language. The usual building blocks of languages (including union, concatenation, and Kleene closure) have precise and compelling specifications uncomplicated by operational strategies and are easily generalized to a few general domain-transforming and codomain-transforming operations on predicates. A simple characterization of languages (and indeed functions from lists to any type) captures the essential idea behind language “differentiation” as used for recognizing languages, leading to a collection of lemmas about type-level predicates. These lemmas are the heart of two dual parsing implementations—using (inductive) regular expressions and (coinductive) tries—each containing the same code but in dual arrangements (with representation and primitive operations trading places). The regular expression version corresponds to symbolic differentiation, while the trie version corresponds to automatic differentiation. The relatively easy-to-prove properties of type-level languages transfer almost effortlessly to the decidable implementations. In particular, despite the inductive and coinductive nature of regular expressions and tries respectively, we need neither inductive nor coinductive/bisimulation arguments to prove algebraic properties.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {78},
numpages = {18},
keywords = {tries, program calculation, language derivatives}
}

@online{fix-ing-regular-expressions,
author={Grenrus, Oleg},
title={Fix-ing regular expressions},
year={2020},
url={https://well-typed.com/blog/2020/06/fix-ing-regular-expressions/},
note={Accessed: 2024-12-12},
}

@Inbook{Bekic1984,
author="Beki{\'{c}}, Hans",
editor="Jones, C. B.",
title="Definable operations in general algebras, and the theory of automata and flowcharts",
bookTitle="Programming Languages and Their Definition: H. Beki{\v{c}} (1936--1982)",
year="1984",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="30--55",
abstract="We study the class of operations definable from the given operations of an algebra of sets by union, composition, and fixed points; we obtain two theorems on definable operations that give us as special case the regular-equals-recognisable theorem of generalised finite automata theory. Definable operations arise also as the operations computable by charts; by translating into predicate logic, we obtain Manna's formulas for termination and correctness of flowcharts.",
isbn="978-3-540-38933-0",
doi="10.1007/BFb0048939",
url="https://doi.org/10.1007/BFb0048939"
}


@InProceedings{SchwerdfegerW09,
  author       = {August Schwerdfeger and Eric Van Wyk},
  title        = {Verifiable Parse Table Composition for Deterministic Parsing},
  year         = 2009,
  booktitle    = {Software Language Engineering, Second International
                  Conference, {SLE} 2009, Denver, CO, USA, October 5-6, 2009,
                  Revised Selected Papers},
  pages        = {184-203},
  doi          = {10.1007/978-3-642-12107-4\_15},
  url          = {https://doi.org/10.1007/978-3-642-12107-4\_15},
  crossref     = {DBLP:conf/sle/2009},
  timestamp    = {Mon, 21 Jun 2021 12:26:17 +0200},
  biburl       = {https://dblp.org/rec/conf/sle/SchwerdfegerW09.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:conf/sle/2009,
  editor       = {Mark van den Brand and
                  Dragan Gasevic and
                  Jeff Gray},
  title        = {Software Language Engineering, Second International Conference, {SLE}
                  2009, Denver, CO, USA, October 5-6, 2009, Revised Selected Papers},
  series       = {Lecture Notes in Computer Science},
  volume       = {5969},
  publisher    = {Springer},
  year         = {2010},
  url          = {https://doi.org/10.1007/978-3-642-12107-4},
  doi          = {10.1007/978-3-642-12107-4},
  isbn         = {978-3-642-12106-7},
  timestamp    = {Wed, 19 Feb 2025 13:36:10 +0100},
  biburl       = {https://dblp.org/rec/conf/sle/2009.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@Article{BrabrandGM10,
  author       = {Claus Brabrand and Robert Giegerich and Anders M{\o}ller},
  title        = {Analyzing ambiguity of context-free grammars},
  journal      = {Sci. Comput. Program.},
  year         = 2010,
  volume       = 75,
  number       = 3,
  pages        = {176-191},
  doi          = {10.1016/J.SCICO.2009.11.002},
  url          = {https://doi.org/10.1016/j.scico.2009.11.002},
  timestamp    = {Wed, 17 Feb 2021 21:56:01 +0100},
  biburl       = {https://dblp.org/rec/journals/scp/BrabrandGM10.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@phdthesis{basten-thesis,
  TITLE = {{Ambiguity Detection for Programming Language Grammars}},
  AUTHOR = {Basten, Bas},
  URL = {https://theses.hal.science/tel-00644079},
  SCHOOL = {{Universiteit van Amsterdam}},
  YEAR = {2011},
  MONTH = Dec,
  KEYWORDS = {context-free grammars ; programming languages ; ambiguity detection ; static analysis ; scannerless},
  TYPE = {Theses},
  PDF = {https://theses.hal.science/tel-00644079v1/file/PhDThesis_Bas_Basten.pdf},
  HAL_ID = {tel-00644079},
  HAL_VERSION = {v1},
}

@Book{hopcroft-book,
  author       = {John E. Hopcroft and Rajeev Motwani and Jeffrey D. Ullman},
  title        = {Introduction to automata theory, languages, and computation,
                  3rd Edition},
  year         = 2007,
  series       = {Pearson international edition},
  publisher    = {Addison-Wesley},
  isbn         = {978-0-321-47617-3},
  timestamp    = {Thu, 02 Jan 2020 12:13:44 +0100},
  biburl       = {https://dblp.org/rec/books/daglib/0016921.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{Thiemann17,
  author       = {Peter Thiemann},
  title        = {Partial Derivatives for Context-Free Languages - From
                  {\textbackslash}mu -Regular Expressions to Pushdown Automata},
  year         = 2017,
  booktitle    = {Foundations of Software Science and Computation Structures -
                  20th International Conference, {FOSSACS} 2017, Held as Part of
                  the European Joint Conferences on Theory and Practice of
                  Software, {ETAPS} 2017, Uppsala, Sweden, April 22-29, 2017,
                  Proceedings},
  pages        = {248-264},
  doi          = {10.1007/978-3-662-54458-7\_15},
  url          = {https://doi.org/10.1007/978-3-662-54458-7\_15},
  crossref     = {DBLP:conf/fossacs/2017},
  timestamp    = {Mon, 23 Mar 2020 12:22:51 +0100},
  biburl       = {https://dblp.org/rec/conf/fossacs/Thiemann17.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@proceedings{DBLP:conf/fossacs/2017,
  editor       = {Javier Esparza and
                  Andrzej S. Murawski},
  title        = {Foundations of Software Science and Computation Structures - 20th
                  International Conference, {FOSSACS} 2017, Held as Part of the European
                  Joint Conferences on Theory and Practice of Software, {ETAPS} 2017,
                  Uppsala, Sweden, April 22-29, 2017, Proceedings},
  series       = {Lecture Notes in Computer Science},
  volume       = {10203},
  year         = {2017},
  url          = {https://doi.org/10.1007/978-3-662-54458-7},
  doi          = {10.1007/978-3-662-54458-7},
  isbn         = {978-3-662-54457-0},
  timestamp    = {Wed, 19 Feb 2025 13:43:25 +0100},
  biburl       = {https://dblp.org/rec/conf/fossacs/2017.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{yallop,
author = {Krishnaswami, Neelakantan R. and Yallop, Jeremy},
title = {A typed, algebraic approach to parsing},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314625},
doi = {10.1145/3314221.3314625},
abstract = {In this paper, we recall the definition of the context-free expressions (or µ-regular expressions), an algebraic presentation of the context-free languages. Then, we define a core type system for the context-free expressions which gives a compositional criterion for identifying those context-free expressions which can be parsed unambiguously by predictive algorithms in the style of recursive descent or LL(1). Next, we show how these typed grammar expressions can be used to derive a parser combinator library which both guarantees linear-time parsing with no backtracking and single-token lookahead, and which respects the natural denotational semantics of context-free expressions. Finally, we show how to exploit the type information to write a staged version of this library, which produces dramatic increases in performance, even outperforming code generated by the standard parser generator tool ocamlyacc.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {379–393},
numpages = {15},
keywords = {type theory, parsing, context-free languages, Kleene algebra},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}


@conference{agdarsec,
title = "Agdarsec - total parser combinators",
abstract = "Parser combinator libraries represent parsers as functions and, using higher-order functions, define a DSL of combinators allowing users to quickly put together programs capable of handling complex recursive grammars. When moving to total functional languages such as Agda, these programs cannot be directly ported: there is nothing in the original definitions guaranteeing termination. In this paper, we will introduce a 'guarded' modal operator acting on types and show how it allows us to give more precise types to existing combinators thus guaranteeing totality.",
keywords = "total parser combinators, higher-order functions, total functional languages",
author = "Guillaume Allais",
note = "Publisher Copyright: {\textcopyright} JFLA 2018 - Journees Francophones des Langages Applicatifs. All rights reserved. Sylvie Boldo, Nicolas Magaud. Journ{\'e}es Francophones des Langages Applicatifs 2018. Sylvie Boldo; Nicolas Magaud. Journ{\'e}es Francophones des Langages Applicatifs 2018, Jan 2018, Banyuls-sur-Mer, France. publi{\'e} par les auteurs, 2018. ⟨hal-01707376⟩; Vingt-neuviemes Journees Francophones des Langages Applicatifs, JFLA 2018 - 29th French-Speaking Conference on Applicative Languages, JFLA 2018 ; Conference date: 24-01-2018 Through 27-01-2018",
year = "2018",
month = feb,
day = "12",
language = "English",
pages = "45--59",
}

@inproceedings{10.1145/1863543.1863585,
author = {Danielsson, Nils Anders},
title = {Total parser combinators},
year = {2010},
isbn = {9781605587943},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1863543.1863585},
doi = {10.1145/1863543.1863585},
abstract = {A monadic parser combinator library which guarantees termination of parsing, while still allowing many forms of left recursion, is described. The library's interface is similar to those of many other parser combinator libraries, with two important differences: one is that the interface clearly specifies which parts of the constructed parsers may be infinite, and which parts have to be finite, using dependent types and a combination of induction and coinduction; and the other is that the parser type is unusually informative.The library comes with a formal semantics, using which it is proved that the parser combinators are as expressive as possible. The implementation is supported by a machine-checked correctness proof.},
booktitle = {Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming},
pages = {285–296},
numpages = {12},
keywords = {termination, productivity, parser combinators, mixed induction and coinduction, dependent types},
location = {Baltimore, Maryland, USA},
series = {ICFP '10}
}

@article{total-parser-combinators,
author = {Danielsson, Nils Anders},
title = {Total parser combinators},
year = {2010},
issue_date = {September 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1932681.1863585},
doi = {10.1145/1932681.1863585},
abstract = {A monadic parser combinator library which guarantees termination of parsing, while still allowing many forms of left recursion, is described. The library's interface is similar to those of many other parser combinator libraries, with two important differences: one is that the interface clearly specifies which parts of the constructed parsers may be infinite, and which parts have to be finite, using dependent types and a combination of induction and coinduction; and the other is that the parser type is unusually informative.The library comes with a formal semantics, using which it is proved that the parser combinators are as expressive as possible. The implementation is supported by a machine-checked correctness proof.},
journal = {SIGPLAN Not.},
month = sep,
pages = {285–296},
numpages = {12},
keywords = {termination, productivity, parser combinators, mixed induction and coinduction, dependent types}
}

@InProceedings{dependently-typed-grammars,
author="Brink, Kasper
and Holdermans, Stefan
and L{\"o}h, Andres",
editor="Bolduc, Claude
and Desharnais, Jules
and Ktari, B{\'e}chir",
title="Dependently Typed Grammars",
booktitle="Mathematics of Program Construction",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="58--79",
abstract="Parser combinators are a popular tool for designing parsers in functional programming languages. If such combinators generate an abstract representation of the grammar as an intermediate step, it becomes easier to perform analyses and transformations that can improve the behaviour of the resulting parser. Grammar transformations must satisfy a number of invariants. In particular, they have to preserve the semantics associated with the grammar. Using conventional type systems, these constraints cannot be expressed satisfactorily, but as we show in this article, dependent types are a natural fit. We present a framework for grammars and grammar transformations using Agda. We implement the left-corner transformation for left-recursion removal and prove a language-inclusion property as use cases.",
isbn="978-3-642-13321-3"
}

@article{certified-valiant,
  author       = {Jean{-}Philippe Bernardy and
                  Patrik Jansson},
  title        = {Certified Context-Free Parsing: {A} formalisation of Valiant's Algorithm
                  in Agda},
  journal      = {Log. Methods Comput. Sci.},
  volume       = {12},
  number       = {2},
  year         = {2016},
  url          = {https://doi.org/10.2168/LMCS-12(2:6)2016},
  doi          = {10.2168/LMCS-12(2:6)2016},
  timestamp    = {Thu, 25 Jun 2020 21:28:58 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/BernardyJ16.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}