@article{monadic-parsing, title={Monadic parsing in Haskell}, volume={8}, DOI={10.1017/S0956796898003050}, number={4}, journal={Journal of Functional Programming}, author={Hutton, Graham and Meijer, Erik}, year={1998}, pages={437–444}}

@techreport{parsec,
author = {Leijen, Daan and Meijer, Erik},
title = {Parsec: Direct Style Monadic Parser Combinators for the Real World},
year = {2001},
month = {July},
abstract = {Despite the long list of publications on parser combinators, there does not yet exist a monadic parser combinator library that is applicable in real world situations. In particular naive implementations of parser combinators are likely to suffer from space leaks and are often unable to report precise error messages in case of parse errors. The Parsec parser combinator library described in this paper, utilizes a novel implementation technique for space and time efficient parser combinators that in case of a parse error, report both the position of the error as well as all grammar productions that would have been legal at that point in the input.},
url = {https://www.microsoft.com/en-us/research/publication/parsec-direct-style-monadic-parser-combinators-for-the-real-world/},
edition = {Technical Report UU-CS-2001-35, Departement of Computer Science, Universiteit Utrecht},
number = {UU-CS-2001-27},
note = {User Modeling 2007, 11th International Conference, UM 2007, Corfu, Greece, June 25-29, 2007},
}

@incollection{combinator-parsing-short-tutorial,
  title={Combinator parsing: A short tutorial},
  author={Swierstra, S Doaitse},
  booktitle={International LerNet ALFA Summer School on Language Engineering and Rigorous Software Development},
  pages={252--300},
  year={2008},
  publisher={Springer}
}

@inproceedings{design-patterns-for-parser-combinators,
author = {Willis, Jamie and Wu, Nicolas},
title = {Design patterns for parser combinators (functional pearl)},
year = {2021},
isbn = {9781450386159},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/3471874.3472984},
doi = {10.1145/3471874.3472984},
abstract = {Parser combinators are a popular and elegant approach for parsing in functional languages. The design and implementation of such libraries are well discussed, but having a well-designed library is only one-half of the story. In this paper we explore several reusable approaches to writing parsers in combinator style, focusing on easy to apply patterns to keep parsing code simple, separated, and maintainable.},
booktitle = {Proceedings of the 14th ACM SIGPLAN International Symposium on Haskell},
pages = {71–84},
numpages = {14},
keywords = {parser combinators},
location = {Virtual, Republic of Korea},
series = {Haskell 2021}
}

@inproceedings{one-parser-to-rule-them-all,
author = {Afroozeh, Ali and Izmaylova, Anastasia},
title = {One parser to rule them all},
year = {2015},
isbn = {9781450336888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/2814228.2814242},
doi = {10.1145/2814228.2814242},
abstract = {Despite the long history of research in parsing, constructing parsers for real programming languages remains a difficult and painful task. In the last decades, different parser generators emerged to allow the construction of parsers from a BNF-like specification. However, still today, many parsers are handwritten, or are only partly generated, and include various hacks to deal with different peculiarities in programming languages. The main problem is that current declarative syntax definition techniques are based on pure context-free grammars, while many constructs found in programming languages require context information. In this paper we propose a parsing framework that embraces context information in its core. Our framework is based on data-dependent grammars, which extend context-free grammars with arbitrary computation, variable binding and constraints. We present an implementation of our framework on top of the Generalized LL (GLL) parsing algorithm, and show how common idioms in syntax of programming languages such as (1) lexical disambiguation filters, (2) operator precedence, (3) indentation-sensitive rules, and (4) conditional preprocessor directives can be mapped to data-dependent grammars. We demonstrate the initial experience with our framework, by parsing more than 20000 Java, C#, Haskell, and OCaml source files.},
booktitle = {2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward!)},
pages = {151–170},
numpages = {20},
keywords = {GLL, Parsing, context-aware scanning, data-dependent grammars, disambiguation, offside rule, operator precedence, preprocessor directives, scannerless parsing},
location = {Pittsburgh, PA, USA},
series = {Onward! 2015}
}

@inproceedings{general-parser-combinators,
author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs van der},
title = {Practical, general parser combinators},
year = {2016},
isbn = {9781450340977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/2847538.2847539},
doi = {10.1145/2847538.2847539},
abstract = {Parser combinators are a popular approach to parsing where context-free grammars are represented as executable code. However, conventional parser combinators do not support left recursion, and can have worst-case exponential runtime. These limitations hinder the expressivity and performance predictability of parser combinators when constructing parsers for programming languages. In this paper we present general parser combinators that support all context-free grammars and construct a parse forest in cubic time and space in the worst case, while behaving nearly linearly on grammars of real programming languages. Our general parser combinators are based on earlier work on memoized Continuation-Passing Style (CPS) recognizers. First, we extend this work to achieve recognition in cubic time. Second, we extend the resulting cubic CPS recognizers to parsers that construct a binarized Shared Packed Parse Forest (SPPF). Our general parser combinators bring the best of both worlds: the flexibility and extensibility of conventional parser combinators and the expressivity and performance guarantees of general parsing algorithms. We used the approach presented in this paper as the basis for Meerkat, a general parser combinator library for Scala.},
booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
pages = {1–12},
numpages = {12},
keywords = {Parser combinators, continuation-passing style, general parsing, higher-order functions, left recursion, memoization},
location = {St. Petersburg, FL, USA},
series = {PEPM '16}
}

@article{brzozowski,
author = {Brzozowski, Janusz A.},
title = {Derivatives of Regular Expressions},
year = {1964},
issue_date = {Oct. 1964},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {11},
number = {4},
issn = {0004-5411},
dontuseurl = {https://doi.org/10.1145/321239.321249},
doi = {10.1145/321239.321249},
journal = {J. ACM},
month = oct,
pages = {481–494},
numpages = {14}
}

@article{10.1145/2034574.2034801,
author = {Might, Matthew and Darais, David and Spiewak, Daniel},
title = {Parsing with derivatives: a functional pearl},
year = {2011},
issue_date = {September 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {9},
issn = {0362-1340},
dontuseurl = {https://doi.org/10.1145/2034574.2034801},
doi = {10.1145/2034574.2034801},
abstract = {We present a functional approach to parsing unrestricted context-free grammars based on Brzozowski's derivative of regular expressions. If we consider context-free grammars as recursive regular expressions, Brzozowski's equational theory extends without modification to context-free grammars (and it generalizes to parser combinators). The supporting actors in this story are three concepts familiar to functional programmers - laziness, memoization and fixed points; these allow Brzozowski's original equations to be transliterated into purely functional code in about 30 lines spread over three functions.Yet, this almost impossibly brief implementation has a drawback: its performance is sour - in both theory and practice. The culprit? Each derivative can double the size of a grammar, and with it, the cost of the next derivative.Fortunately, much of the new structure inflicted by the derivative is either dead on arrival, or it dies after the very next derivative. To eliminate it, we once again exploit laziness and memoization to transliterate an equational theory that prunes such debris into working code. Thanks to this compaction, parsing times become reasonable in practice.We equip the functional programmer with two equational theories that, when combined, make for an abbreviated understanding and implementation of a system for parsing context-free languages.},
journal = {SIGPLAN Not.},
month = sep,
pages = {189–195},
numpages = {7},
keywords = {regular expressions, parsing, parser combinator, formal languages, derivative, context-free grammar}
}

@inproceedings{parsing-with-derivatives,
author = {Might, Matthew and Darais, David and Spiewak, Daniel},
title = {Parsing with derivatives: a functional pearl},
year = {2011},
isbn = {9781450308656},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
dontuseurl = {https://doi.org/10.1145/2034773.2034801},
doi = {10.1145/2034773.2034801},
abstract = {We present a functional approach to parsing unrestricted context-free grammars based on Brzozowski's derivative of regular expressions. If we consider context-free grammars as recursive regular expressions, Brzozowski's equational theory extends without modification to context-free grammars (and it generalizes to parser combinators). The supporting actors in this story are three concepts familiar to functional programmers - laziness, memoization and fixed points; these allow Brzozowski's original equations to be transliterated into purely functional code in about 30 lines spread over three functions.Yet, this almost impossibly brief implementation has a drawback: its performance is sour - in both theory and practice. The culprit? Each derivative can double the size of a grammar, and with it, the cost of the next derivative.Fortunately, much of the new structure inflicted by the derivative is either dead on arrival, or it dies after the very next derivative. To eliminate it, we once again exploit laziness and memoization to transliterate an equational theory that prunes such debris into working code. Thanks to this compaction, parsing times become reasonable in practice.We equip the functional programmer with two equational theories that, when combined, make for an abbreviated understanding and implementation of a system for parsing context-free languages.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Conference on Functional Programming},
pages = {189–195},
numpages = {7},
keywords = {regular expressions, parsing, parser combinator, formal languages, derivative, context-free grammar},
location = {Tokyo, Japan},
series = {ICFP '11}
}

@article{conal-languages,
author = {Elliott, Conal},
title = {Symbolic and automatic differentiation of languages},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
dontuseurl = {https://doi.org/10.1145/3473583},
doi = {10.1145/3473583},
abstract = {Formal languages are usually defined in terms of set theory. Choosing type theory instead gives us languages as type-level predicates over strings. Applying a language to a string yields a type whose elements are language membership proofs describing how a string parses in the language. The usual building blocks of languages (including union, concatenation, and Kleene closure) have precise and compelling specifications uncomplicated by operational strategies and are easily generalized to a few general domain-transforming and codomain-transforming operations on predicates. A simple characterization of languages (and indeed functions from lists to any type) captures the essential idea behind language “differentiation” as used for recognizing languages, leading to a collection of lemmas about type-level predicates. These lemmas are the heart of two dual parsing implementations—using (inductive) regular expressions and (coinductive) tries—each containing the same code but in dual arrangements (with representation and primitive operations trading places). The regular expression version corresponds to symbolic differentiation, while the trie version corresponds to automatic differentiation. The relatively easy-to-prove properties of type-level languages transfer almost effortlessly to the decidable implementations. In particular, despite the inductive and coinductive nature of regular expressions and tries respectively, we need neither inductive nor coinductive/bisimulation arguments to prove algebraic properties.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {78},
numpages = {18},
keywords = {tries, program calculation, language derivatives}
}

@online{fix-ing-regular-expressions,
author={Grenrus, Oleg},
title={Fix-ing regular expressions},
year={2020},
url={https://well-typed.com/blog/2020/06/fix-ing-regular-expressions/},
note={Accessed: 2024-12-12},
}

@Inbook{Bekic1984,
author="Beki{\'{c}}, Hans",
editor="Jones, C. B.",
title="Definable operations in general algebras, and the theory of automata and flowcharts",
bookTitle="Programming Languages and Their Definition: H. Beki{\v{c}} (1936--1982)",
year="1984",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="30--55",
abstract="We study the class of operations definable from the given operations of an algebra of sets by union, composition, and fixed points; we obtain two theorems on definable operations that give us as special case the regular-equals-recognisable theorem of generalised finite automata theory. Definable operations arise also as the operations computable by charts; by translating into predicate logic, we obtain Manna's formulas for termination and correctness of flowcharts.",
isbn="978-3-540-38933-0",
doi="10.1007/BFb0048939",
url="https://doi.org/10.1007/BFb0048939"
}
